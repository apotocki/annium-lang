/*
let v0 = [1, 2, 3];

assert_equal(size(v0), 3);
assert_equal(v0[0], 1);
assert_equal(v0[1], 2);
assert_equal(v0[2], 3);

let v1 = [1, runtime_cast(2), 3];
assert_equal(size(v1), 3);
assert_equal(v1[0], 1);
assert_equal(v1[1], 2);
assert_equal(v1[2], 3);

let v2 = [1, 3.1];
assert_equal(size(v2), 2);
assert_equal(v2[0], 1);
assert_equal(v2[1], 3.1);
*/

//fn apply(to: union(...), visitor: _) -> auto

fn equal($l: ~union(...), $r) -> bool {
    //let tmp = $l;
    //let tmp1 = tmp;
    return apply(to: $l, visitor: fn($value)->bool {
        return $value == $r;
    });
}


//fn implicit_cast(:~union(...)) -> $T {
    //return apply(to: $0, visitor: fn($value)->$T { return implicit_cast($value); });
    //return apply(visitor: fn($value)->$T => implicit_cast($value)`, to: $0 );
//    return apply(to: $0, visitor: fn($value)->$T => ::implicit_cast($value)`);
//}

let v3 = [1, runtime_cast(3.1)];
assert_equal(size(v3), 2);
//assert_equal(1, v3[0]);
assert_equal(v3[1], 3.1);

//get(self: union(_...), property:= .witch)->integer => implementation defined
