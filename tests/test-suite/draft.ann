
let v0 = [1, runtime_cast(2), 3.1];

//let v0str = [{ for $v in $v0 { yield to_string($v); }}];
//let v0str = [{ yield "abc"; }];
//print(to_string(v0));

typefn array(of: typename, size?: constexpr integer);

struct iterator(typename array(of, ...)) => (index: integer = 0, array: $0);
inline fn has_next($it: ~iterator(=array(of, ...))) -> bool => $it.index != size($it.array);
inline fn next($it: ~iterator(=array(of $of, ...))) -> $of {
    let v = $it.array[$it.index];
    $it.index = $it.index + 1;
    return v;
}
inline fn iterator(~array(...)) -> iterator(typeof($0)) => init(array: $0);

let it = iterator(v0);
assert(has_next(it));
assert(next(it) == 1);

/*
fn iterator(v: array()) {
    for $i in 0 .. size(v) - 1 {
        let vi = v[$i];
        print("v[" + to_string($i) + "] = " + to_string(vi));
        if (typeof(vi) == integer) {
            print("  (integer)");
        } else if (typeof(vi) == float) {
            print("  (float)");
        } else {
            print("  (unknown type)");
        }
    }
}
*/
/*
assert_equal(size(v0), 3);
assert_equal(v0[0], 1);
assert_equal(v0[1], 2);
assert_equal(v0[2], 3);

let v1 = [1, runtime_cast(2), 3];
assert_equal(size(v1), 3);
assert_equal(v1[0], 1);
assert_equal(v1[1], 2);
assert_equal(v1[2], 3);

let v2 = [1, 3.1];
assert_equal(size(v2), 2);
assert_equal(v2[0], 1);
assert_equal(v2[1], 3.1);
*/
