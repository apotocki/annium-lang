fn builder(value: runtime string, $second: runtime integer)->(string)->string {
    return fn[value: value, $second](string) => $0 .. value .. to_string($second);
}
extern var eftor: (string)->string;
eftor = builder(value: " external functor!", 22);
let result: string = __extern_invoke("eftor_call", "Hello,", 1);
assert_equal(result, "Hello, external functor!22");


//let result: string = __extern_invoke("eftor_call", "Hello,", 1);
//__extern_invoke("eftor_call", "Hello,", 1);
//print(result);

//let l1 = builder(value: " World!", 22);
//print(l1("Hello,"));
//assert_equal(l1("Hello,"), "Hello, World!22");

/*
fn my_print0()->() {
    print("0");
}

let ftor0_rt: ()->() = runtime_cast(my_print0);
ftor0_rt();
*/
//assert_equal(concat_rt("Hello, ", "Runtime!"), "Hello, Runtime!");

/*
fn num_arr_to_string(:[integer|decimal])->[string] {
    return make_array(from_iterator: make_transform_iterator(from_iterator: iterator($0), functor: fn($x)->string => to_string($x)`));
}
let v3 = [runtime_cast(2)];
let strings2 = num_arr_to_string(v3);
*/

// Test: tuples with mixed const/non-const fields
//let x = runtime_cast(42);
//let t3 = (a: x, b: 2, c: runtime_cast(3), d: 4);
//let t4 = (a: x, b: 2, c: 3, d: runtime_cast(4));

//let f = t3 == t4;
//assert(t3 == t4);

//print(to_string(typeof(v1)));

//let v0 = [runtime_cast(1), runtime_cast(2), runtime_cast(3)];

//let v0str = [{ for $v in $v0 { yield to_string($v); }}];
//let v0str = [{ yield "abc"; }];
//print(to_string(v0));


//if v0.0 != 3.1 {
//    let vstr = apply(to: v0.2, visitor: fn($x) => to_string($x)`);
//    print(vstr);
//}

//for v in v0 {
//    print(to_string(v));
//    //print(apply(to: v, visitor: fn($x) => to_string($x)`), ", ");
//}
