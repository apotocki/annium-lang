
fn my_print0()->() {
    print("0");
}

fn my_print0(string)->() {
    print($0);
}

fn my_print0(string, string)->() {
    print($0 .. $1);
}

fn my_concat(string, string)->string {
    return $0 .. $1;
}

// simple qname as a functor
let ftor = my_print0;
ftor();

ftor("Hello!");
ftor("Hello,", " World!");

// lambda as a functor
(fn() { print("1"); })();
(fn() => print("2"))();

let lambda = fn() => my_print0();
lambda();

// functor type annotations
let ftor0 : ()->() = my_print0;
ftor0();

let ftor1 : string->() = my_print0;
ftor1("3");
assert_equal(__get_frame_stack_height(), 0);

let ftor1a : (string)->() = my_print0;
ftor1a("3a");
assert_equal(__get_frame_stack_height(), 0);

let ftor2 : (string, string)->() = my_print0;
ftor2("4", "d");

let concat_ct: (string, string)->string = my_concat;
assert_equal(concat_ct("Hello, ", "Compile time!"), "Hello, Compile time!");

// lambda to functor type annotation
let lambda0 : ()->() = fn() => my_print0();
lambda0();

let lambda1 : string->() = fn($x) => my_print0($x);
lambda1("5");

let lambda2 : (string, string)->() = fn($x, $y) => my_print0($x, $y);
lambda2("6", "e");

let concat_lambda: (string, string)->string = fn($x, $y) => my_concat($x, $y);
assert_equal(concat_lambda("Hello, ", "Lambda!"), "Hello, Lambda!");

// runtime functors
let ftor0_rt: ()->() = runtime_cast(my_print0);
ftor0_rt();

let ftor1_rt: (string)->() = runtime_cast(my_print0);
ftor1_rt("7");

let ftor2_rt: (string, string)->() = runtime_cast(my_print0);
ftor2_rt("8", "9");

let concat_rt: (string, string)->string = runtime_cast(my_concat);
assert_equal(concat_rt("Hello, ", "Runtime!"), "Hello, Runtime!");

// runtime functors with captured values
fn builder(value: runtime string)->(string)->string {
    return fn[value](string) => $0 .. value;
}

let l1 = builder(value: " World!");
assert_equal(l1("Hello,"), "Hello, World!");

fn builder(value: runtime string, $second: runtime integer)->(string)->string {
    return fn[value: value, $second](string) => $0 .. value .. to_string($second);
}
let l2 = builder(value: " World!", 22);
assert_equal(l2("Hello,"), "Hello, World!22");


extern var eftor: (string)->string;
eftor = builder(value: " external functor!", 22);
let result: string = __extern_invoke("eftor_call", "Hello,", 1);
assert_equal(result, "Hello, external functor!22");

__extern_invoke("iv_call", 23, 1);

/**/